-- filename: xdbsnapshot_scheme.sql
-- name: Create XDBSNAPSHOT database schema and jobs to capture performance metrics periodically
-- description: XDBSNAPSHOT is designed to measure and compare database performance for Oracle Database Software Editions without Diagnostic Pack Licence (AWR).
--				It is designed for XE/SE editions of Oracle Database Software.
-- !Important!
-- 		1. Please change password and tablespace if required.
-- 		2. There are SQL script at the end of the file to check if jobs are running and snapshots are creating 


-- drop user xdbsnapshot cascade;

-- please change tablespace if required 
create user xdbsnapshot identified by "P!@wd012To34"  default tablespace users quota unlimited on users;

grant connect, create session, create table, create sequence, create procedure, create job to xdbsnapshot;

grant select any dictionary to xdbsnapshot;

GRANT EXECUTE ON SYS.DEFAULT_JOB_CLASS TO xdbsnapshot;

CREATE TABLE XDBSNAPSHOT.TBL_ASH
(
	SAMPLE_ID INTEGER,
    SAMPLE_TIME DATE,
    SADDR RAW(8),
	SID NUMBER,
	SERIAL# NUMBER,
	AUDSID NUMBER,
	PADDR RAW(8),
	USER# NUMBER,
	USERNAME VARCHAR2(30),
	COMMAND NUMBER,
	OWNERID NUMBER,
	TADDR VARCHAR2(16),
	LOCKWAIT VARCHAR2(16),
	STATUS VARCHAR2(8),
	SERVER VARCHAR2(9),
	SCHEMA# NUMBER,
	SCHEMANAME VARCHAR2(30),
	OSUSER VARCHAR2(30),
	PROCESS VARCHAR2(24),
	MACHINE VARCHAR2(64),
	PORT NUMBER,
	TERMINAL VARCHAR2(30),
	PROGRAM VARCHAR2(48),
	TYPE VARCHAR2(10),
	SQL_ADDRESS RAW(8),
	SQL_HASH_VALUE NUMBER,
	SQL_ID VARCHAR2(13),
	SQL_CHILD_NUMBER NUMBER,
	SQL_EXEC_START DATE,
	SQL_EXEC_ID NUMBER,
	PREV_SQL_ADDR RAW(8),
	PREV_HASH_VALUE NUMBER,
	PREV_SQL_ID VARCHAR2(13),
	PREV_CHILD_NUMBER NUMBER,
	PREV_EXEC_START DATE,
	PREV_EXEC_ID NUMBER,
	PLSQL_ENTRY_OBJECT_ID NUMBER,
	PLSQL_ENTRY_SUBPROGRAM_ID NUMBER,
	PLSQL_OBJECT_ID NUMBER,
	PLSQL_SUBPROGRAM_ID NUMBER,
	MODULE VARCHAR2(64),
	MODULE_HASH NUMBER,
	ACTION VARCHAR2(64),
	ACTION_HASH NUMBER,
	CLIENT_INFO VARCHAR2(64),
	FIXED_TABLE_SEQUENCE NUMBER,
	ROW_WAIT_OBJ# NUMBER,
	ROW_WAIT_FILE# NUMBER,
	ROW_WAIT_BLOCK# NUMBER,
	ROW_WAIT_ROW# NUMBER,
	TOP_LEVEL_CALL# NUMBER,
	LOGON_TIME DATE,
	LAST_CALL_ET NUMBER,
	PDML_ENABLED VARCHAR2(3),
	FAILOVER_TYPE VARCHAR2(13),
	FAILOVER_METHOD VARCHAR2(10),
	FAILED_OVER VARCHAR2(3),
	RESOURCE_CONSUMER_GROUP VARCHAR2(32),
	PDML_STATUS VARCHAR2(8),
	PDDL_STATUS VARCHAR2(8),
	PQ_STATUS VARCHAR2(8),
	CURRENT_QUEUE_DURATION NUMBER,
	CLIENT_IDENTIFIER VARCHAR2(64),
	BLOCKING_SESSION_STATUS VARCHAR2(11),
	BLOCKING_INSTANCE NUMBER,
	BLOCKING_SESSION NUMBER,
	FINAL_BLOCKING_SESSION_STATUS VARCHAR2(11),
	FINAL_BLOCKING_INSTANCE NUMBER,
	FINAL_BLOCKING_SESSION NUMBER,
	SEQ# NUMBER,
	EVENT# NUMBER,
	EVENT VARCHAR2(64),
	P1TEXT VARCHAR2(64),
	P1 NUMBER,
	P1RAW RAW(8),
	P2TEXT VARCHAR2(64),
	P2 NUMBER,
	P2RAW RAW(8),
	P3TEXT VARCHAR2(64),
	P3 NUMBER,
	P3RAW RAW(8),
	WAIT_CLASS_ID NUMBER,
	WAIT_CLASS# NUMBER,
	WAIT_CLASS VARCHAR2(64),
	WAIT_TIME NUMBER,
	SECONDS_IN_WAIT NUMBER,
	STATE VARCHAR2(19),
	WAIT_TIME_MICRO NUMBER,
	TIME_REMAINING_MICRO NUMBER,
	TIME_SINCE_LAST_WAIT_MICRO NUMBER,
	SERVICE_NAME VARCHAR2(64),
	SQL_TRACE VARCHAR2(8),
	SQL_TRACE_WAITS VARCHAR2(5),
	SQL_TRACE_BINDS VARCHAR2(5),
	SQL_TRACE_PLAN_STATS VARCHAR2(10),
	SESSION_EDITION_ID NUMBER,
	CREATOR_ADDR RAW(8),
	CREATOR_SERIAL# NUMBER,
	ECID VARCHAR2(64),
	SQL_TRANSLATION_PROFILE_ID NUMBER,
	PGA_TUNABLE_MEM NUMBER,
	CON_ID NUMBER,
	EXTERNAL_NAME VARCHAR2(1024)
);

CREATE TABLE XDBSNAPSHOT.TBL_SYS_TIME_MODEL 
(
	SAMPLE_ID INTEGER,
    SAMPLE_TIME DATE,
    STAT_ID NUMBER,
	STAT_NAME VARCHAR2(64),
	VALUE NUMBER,
	CON_ID NUMBER
);

CREATE TABLE XDBSNAPSHOT.TBL_SYSSTAT 
(
	SAMPLE_ID INTEGER,
    SAMPLE_TIME DATE,
    STATISTIC# NUMBER,
	NAME VARCHAR2(64),
	CLASS NUMBER,
	VALUE NUMBER,
	STAT_ID NUMBER,
	CON_ID NUMBER
);

CREATE TABLE XDBSNAPSHOT.TBL_SYSTEM_EVENT
(
	SAMPLE_ID INTEGER,
    SAMPLE_TIME DATE,
    EVENT VARCHAR2(64),
	TOTAL_WAITS NUMBER,
	TOTAL_TIMEOUTS NUMBER,
	TIME_WAITED NUMBER,
	AVERAGE_WAIT NUMBER,
	TIME_WAITED_MICRO NUMBER,
	TOTAL_WAITS_FG NUMBER,
	TOTAL_TIMEOUTS_FG NUMBER,
	TIME_WAITED_FG NUMBER,
	AVERAGE_WAIT_FG NUMBER,
	TIME_WAITED_MICRO_FG NUMBER,
	EVENT_ID NUMBER,
	WAIT_CLASS_ID NUMBER,
	WAIT_CLASS# NUMBER,
	WAIT_CLASS VARCHAR2(64),
	CON_ID NUMBER
);

CREATE TABLE XDBSNAPSHOT.TBL_SQLSTATS
(
	SAMPLE_ID INTEGER,
    SAMPLE_TIME DATE,
    SQL_ID VARCHAR2(13),
	LAST_ACTIVE_TIME DATE,
	LAST_ACTIVE_CHILD_ADDRESS RAW(8),
	PLAN_HASH_VALUE NUMBER,
	PARSE_CALLS NUMBER,
	DISK_READS NUMBER,
	DIRECT_WRITES NUMBER,
	BUFFER_GETS NUMBER,
	ROWS_PROCESSED NUMBER,
	SERIALIZABLE_ABORTS NUMBER,
	FETCHES NUMBER,
	EXECUTIONS NUMBER,
	END_OF_FETCH_COUNT NUMBER,
	LOADS NUMBER,
	VERSION_COUNT NUMBER,
	INVALIDATIONS NUMBER,
	PX_SERVERS_EXECUTIONS NUMBER,
	CPU_TIME NUMBER,
	ELAPSED_TIME NUMBER,
	AVG_HARD_PARSE_TIME NUMBER,
	APPLICATION_WAIT_TIME NUMBER,
	CONCURRENCY_WAIT_TIME NUMBER,
	CLUSTER_WAIT_TIME NUMBER,
	USER_IO_WAIT_TIME NUMBER,
	PLSQL_EXEC_TIME NUMBER,
	JAVA_EXEC_TIME NUMBER,
	SORTS NUMBER,
	SHARABLE_MEM NUMBER,
	TOTAL_SHARABLE_MEM NUMBER,
	TYPECHECK_MEM NUMBER,
	IO_CELL_OFFLOAD_ELIGIBLE_BYTES NUMBER,
	IO_INTERCONNECT_BYTES NUMBER,
	PHYSICAL_READ_REQUESTS NUMBER,
	PHYSICAL_READ_BYTES NUMBER,
	PHYSICAL_WRITE_REQUESTS NUMBER,
	PHYSICAL_WRITE_BYTES NUMBER,
	EXACT_MATCHING_SIGNATURE NUMBER,
	FORCE_MATCHING_SIGNATURE NUMBER,
	IO_CELL_UNCOMPRESSED_BYTES NUMBER,
	IO_CELL_OFFLOAD_RETURNED_BYTES NUMBER,
	DELTA_PARSE_CALLS NUMBER,
	DELTA_DISK_READS NUMBER,
	DELTA_DIRECT_WRITES NUMBER,
	DELTA_BUFFER_GETS NUMBER,
	DELTA_ROWS_PROCESSED NUMBER,
	DELTA_FETCH_COUNT NUMBER,
	DELTA_EXECUTION_COUNT NUMBER,
	DELTA_PX_SERVERS_EXECUTIONS NUMBER,
	DELTA_END_OF_FETCH_COUNT NUMBER,
	DELTA_CPU_TIME NUMBER,
	DELTA_ELAPSED_TIME NUMBER,
	DELTA_APPLICATION_WAIT_TIME NUMBER,
	DELTA_CONCURRENCY_TIME NUMBER,
	DELTA_CLUSTER_WAIT_TIME NUMBER,
	DELTA_USER_IO_WAIT_TIME NUMBER,
	DELTA_PLSQL_EXEC_TIME NUMBER,
	DELTA_JAVA_EXEC_TIME NUMBER,
	DELTA_SORTS NUMBER,
	DELTA_LOADS NUMBER,
	DELTA_INVALIDATIONS NUMBER,
	DELTA_PHYSICAL_READ_REQUESTS NUMBER,
	DELTA_PHYSICAL_READ_BYTES NUMBER,
	DELTA_PHYSICAL_WRITE_REQUESTS NUMBER,
	DELTA_PHYSICAL_WRITE_BYTES NUMBER,
	DELTA_IO_INTERCONNECT_BYTES NUMBER,
	DELTA_CELL_OFFLOAD_ELIG_BYTES NUMBER,
	DELTA_CELL_UNCOMPRESSED_BYTES NUMBER,
	CON_ID NUMBER,
	CON_DBID NUMBER,
	OBSOLETE_COUNT NUMBER
);

CREATE INDEX XDBSNAPSHOT.IDX_SQLSTATS_01 on XDBSNAPSHOT.TBL_SQLSTATS (SAMPLE_ID);

CREATE TABLE XDBSNAPSHOT.TBL_OSSTAT
(
	SAMPLE_ID INTEGER,
    SAMPLE_TIME DATE,
    STAT_NAME VARCHAR2(64),
	VALUE NUMBER,
	OSSTAT_ID NUMBER,
	COMMENTS VARCHAR2(64),
	CUMULATIVE VARCHAR2(3),
	CON_ID NUMBER
);

CREATE TABLE XDBSNAPSHOT.TBL_SNAPSHOT
(
	SAMPLE_ID INTEGER,
    SAMPLE_TIME DATE,
    INSTANCE_NUMBER NUMBER,
	INSTANCE_NAME VARCHAR2(16),
	STARTUP_TIME DATE
);

CREATE INDEX XDBSNAPSHOT.IDX_SNAPSHOT_01 ON XDBSNAPSHOT.TBL_SNAPSHOT (SAMPLE_ID);

CREATE TABLE XDBSNAPSHOT.TBL_SQL_TEXT
(
	SAMPLE_ID INTEGER,
   	SAMPLE_TIME DATE,
   	SQL_ID VARCHAR2(13),
   	SQL_FULLTEXT CLOB
);

CREATE INDEX XDBSNAPSHOT.IDX_SQL_TEXT on XDBSNAPSHOT.TBL_SQL_TEXT (SQL_ID);


CREATE TABLE XDBSNAPSHOT.TBL_SQL_PLAN
(
	SAMPLE_ID INTEGER,
    SAMPLE_TIME DATE,
    ADDRESS RAW(8),
	HASH_VALUE NUMBER,
	SQL_ID VARCHAR2(13),
	PLAN_HASH_VALUE NUMBER,
	FULL_PLAN_HASH_VALUE NUMBER,
	CHILD_ADDRESS RAW(8),
	CHILD_NUMBER NUMBER,
	TIMESTAMP DATE,
	OPERATION VARCHAR2(120),
	OPTIONS VARCHAR2(120),
	OBJECT_NODE VARCHAR2(160),
	OBJECT# NUMBER,
	OBJECT_OWNER VARCHAR2(128),
	OBJECT_NAME VARCHAR2(128),
	OBJECT_ALIAS VARCHAR2(261),
	OBJECT_TYPE VARCHAR2(80),
	OPTIMIZER VARCHAR2(80),
	ID NUMBER,
	PARENT_ID NUMBER,
	DEPTH NUMBER,
	POSITION NUMBER,
	SEARCH_COLUMNS NUMBER,
	COST NUMBER,
	CARDINALITY NUMBER,
	BYTES NUMBER,
	OTHER_TAG VARCHAR2(140),
	PARTITION_START VARCHAR2(256),
	PARTITION_STOP VARCHAR2(256),
	PARTITION_ID NUMBER,
	OTHER VARCHAR2(4000),
	DISTRIBUTION VARCHAR2(80),
	CPU_COST NUMBER,
	IO_COST NUMBER,
	TEMP_SPACE NUMBER,
	ACCESS_PREDICATES VARCHAR2(4000),
	FILTER_PREDICATES VARCHAR2(4000),
	PROJECTION VARCHAR2(4000),
	TIME NUMBER,
	QBLOCK_NAME VARCHAR2(30),
	REMARKS VARCHAR2(4000),
	OTHER_XML CLOB,
	CON_ID NUMBER
);

CREATE INDEX XDBSNAPSHOT.IDX_SQL_PLAN on XDBSNAPSHOT.TBL_SQL_PLAN (SQL_ID, PLAN_HASH_VALUE, CHILD_ADDRESS);

CREATE SEQUENCE XDBSNAPSHOT.SEQ_ASH
	START WITH 1
 	INCREMENT BY 1
 	NOCACHE
 	NOCYCLE
;

CREATE SEQUENCE XDBSNAPSHOT.SEQ_AWR
	START WITH 1
 	INCREMENT BY 1
 	NOCACHE
 	NOCYCLE
;

CREATE OR REPLACE PROCEDURE XDBSNAPSHOT.PR_ASH_CAPTURE AUTHID CURRENT_USER
IS
    l_seq NUMBER;
    l_date DATE := sysdate;
BEGIN

    dbms_application_info.set_module('XDBSNAPSHOT','PR_ASH_CAPTURE');

    SELECT XDBSNAPSHOT.SEQ_ASH.nextval INTO l_seq FROM DUAL;

    INSERT INTO XDBSNAPSHOT.TBL_ASH SELECT l_seq, l_date,
  SADDR,
	SID,
	SERIAL#,
	AUDSID,
	PADDR,
	USER#,
	USERNAME,
	COMMAND,
	OWNERID,
	TADDR,
	LOCKWAIT,
	STATUS,
	SERVER,
	SCHEMA#,
	SCHEMANAME,
	OSUSER,
	PROCESS,
	MACHINE,
	PORT,
	TERMINAL,
	PROGRAM,
	TYPE,
	SQL_ADDRESS,
	SQL_HASH_VALUE,
	SQL_ID,
	SQL_CHILD_NUMBER,
	SQL_EXEC_START,
	SQL_EXEC_ID,
	PREV_SQL_ADDR,
	PREV_HASH_VALUE,
	PREV_SQL_ID,
	PREV_CHILD_NUMBER,
	PREV_EXEC_START,
	PREV_EXEC_ID,
	PLSQL_ENTRY_OBJECT_ID,
	PLSQL_ENTRY_SUBPROGRAM_ID,
	PLSQL_OBJECT_ID,
	PLSQL_SUBPROGRAM_ID,
	MODULE,
	MODULE_HASH,
	ACTION,
	ACTION_HASH,
	CLIENT_INFO,
	FIXED_TABLE_SEQUENCE,
	ROW_WAIT_OBJ#,
	ROW_WAIT_FILE#,
	ROW_WAIT_BLOCK#,
	ROW_WAIT_ROW#,
	TOP_LEVEL_CALL#,
	LOGON_TIME,
	LAST_CALL_ET,
	PDML_ENABLED,
	FAILOVER_TYPE,
	FAILOVER_METHOD,
	FAILED_OVER,
	RESOURCE_CONSUMER_GROUP,
	PDML_STATUS,
	PDDL_STATUS,
	PQ_STATUS,
	CURRENT_QUEUE_DURATION,
	CLIENT_IDENTIFIER,
	BLOCKING_SESSION_STATUS,
	BLOCKING_INSTANCE,
	BLOCKING_SESSION,
	FINAL_BLOCKING_SESSION_STATUS,
	FINAL_BLOCKING_INSTANCE,
	FINAL_BLOCKING_SESSION,
	SEQ#,
	EVENT#,
	EVENT,
	P1TEXT,
	P1,
	P1RAW,
	P2TEXT,
	P2,
	P2RAW,
	P3TEXT,
	P3,
	P3RAW,
	WAIT_CLASS_ID,
	WAIT_CLASS#,
	WAIT_CLASS,
	WAIT_TIME,
	SECONDS_IN_WAIT,
	STATE,
	WAIT_TIME_MICRO,
	TIME_REMAINING_MICRO,
	TIME_SINCE_LAST_WAIT_MICRO,
	SERVICE_NAME,
	SQL_TRACE,
	SQL_TRACE_WAITS,
	SQL_TRACE_BINDS,
	SQL_TRACE_PLAN_STATS,
	SESSION_EDITION_ID,
	CREATOR_ADDR,
	CREATOR_SERIAL#,
	ECID,
	SQL_TRANSLATION_PROFILE_ID,
	PGA_TUNABLE_MEM,
	CON_ID,
	EXTERNAL_NAME FROM v$session s where NVL(wait_class,'CPU')!='Idle';

    COMMIT;

END;
/

CREATE OR REPLACE PROCEDURE XDBSNAPSHOT.PR_AWR_CAPTURE AUTHID CURRENT_USER
IS
    l_seq NUMBER;
    l_date DATE := sysdate;
    l_previouse_sample_id NUMBER;
BEGIN

    dbms_application_info.set_module('XDBSNAPSHOT','PR_AWR_CAPTURE');

    SELECT XDBSNAPSHOT.SEQ_AWR.nextval INTO l_seq FROM DUAL;

    SELECT NVL(max(sample_id),0) INTO l_previouse_sample_id FROM XDBSNAPSHOT.TBL_SNAPSHOT;

    INSERT INTO XDBSNAPSHOT.TBL_SNAPSHOT SELECT l_seq, l_date, i.instance_number, instance_name, startup_time FROM v$instance i;

    INSERT INTO XDBSNAPSHOT.TBL_SYS_TIME_MODEL SELECT l_seq, l_date, s.* FROM v$sys_time_model s;

    INSERT INTO XDBSNAPSHOT.TBL_SYSSTAT SELECT l_seq, l_date, s.* FROM v$sysstat s;

    INSERT INTO XDBSNAPSHOT.TBL_SYSTEM_EVENT SELECT l_seq, l_date, s.* FROM v$system_event s;

    INSERT INTO XDBSNAPSHOT.TBL_SQLSTATS SELECT * FROM (
        WITH a AS (SELECT * FROM XDBSNAPSHOT.TBL_SQLSTATS WHERE sample_id = l_previouse_sample_id)
        , b AS (SELECT * FROM v$sqlstats)
        SELECT
            l_seq,
            l_date,
            b.SQL_ID,
            b.LAST_ACTIVE_TIME,
            b.LAST_ACTIVE_CHILD_ADDRESS,
            b.PLAN_HASH_VALUE,
            b.PARSE_CALLS,
            b.DISK_READS,
            b.DIRECT_WRITES,
            b.BUFFER_GETS,
            b.ROWS_PROCESSED,
            b.SERIALIZABLE_ABORTS,
            b.FETCHES,
            b.EXECUTIONS,
            b.END_OF_FETCH_COUNT,
            b.LOADS,
            b.VERSION_COUNT,
            b.INVALIDATIONS,
            b.PX_SERVERS_EXECUTIONS,
            b.CPU_TIME,
            b.ELAPSED_TIME,
            b.AVG_HARD_PARSE_TIME,
            b.APPLICATION_WAIT_TIME,
            b.CONCURRENCY_WAIT_TIME,
            b.CLUSTER_WAIT_TIME,
            b.USER_IO_WAIT_TIME,
            b.PLSQL_EXEC_TIME,
            b.JAVA_EXEC_TIME,
            b.SORTS,
            b.SHARABLE_MEM,
            b.TOTAL_SHARABLE_MEM,
            b.TYPECHECK_MEM,
            b.IO_CELL_OFFLOAD_ELIGIBLE_BYTES,
            b.IO_INTERCONNECT_BYTES,
            b.PHYSICAL_READ_REQUESTS,
            b.PHYSICAL_READ_BYTES,
            b.PHYSICAL_WRITE_REQUESTS,
            b.PHYSICAL_WRITE_BYTES,
            b.EXACT_MATCHING_SIGNATURE,
            b.FORCE_MATCHING_SIGNATURE,
            b.IO_CELL_UNCOMPRESSED_BYTES,
            b.IO_CELL_OFFLOAD_RETURNED_BYTES,
            (NVL(b.PARSE_CALLS,0) - NVL(a.PARSE_CALLS,0)) DELTA_PARSE_CALLS,
            (NVL(b.DISK_READS,0) - NVL(a.DISK_READS,0)) DELTA_DISK_READS,
            (NVL(b.DIRECT_WRITES,0) - NVL(a.DIRECT_WRITES,0)) DELTA_DIRECT_WRITES,
            (NVL(b.BUFFER_GETS,0) - NVL(a.BUFFER_GETS,0)) DELTA_BUFFER_GETS,
            (NVL(b.ROWS_PROCESSED,0) - NVL(a.ROWS_PROCESSED,0)) DELTA_ROWS_PROCESSED,
            (NVL(b.FETCHES,0) - NVL(a.FETCHES,0)) DELTA_FETCH_COUNT,
            (NVL(b.EXECUTIONS,0) - NVL(a.EXECUTIONS,0)) DELTA_EXECUTION_COUNT,
            (NVL(b.PX_SERVERS_EXECUTIONS,0) - NVL(a.PX_SERVERS_EXECUTIONS,0)) DELTA_PX_SERVERS_EXECUTIONS,
            (NVL(b.END_OF_FETCH_COUNT,0) - NVL(a.END_OF_FETCH_COUNT,0)) DELTA_END_OF_FETCH_COUNT,
            (NVL(b.CPU_TIME,0) - NVL(a.CPU_TIME,0)) DELTA_CPU_TIME,
            (NVL(b.ELAPSED_TIME,0) - NVL(a.ELAPSED_TIME,0)) DELTA_ELAPSED_TIME,
            (NVL(b.APPLICATION_WAIT_TIME,0) - NVL(a.APPLICATION_WAIT_TIME,0)) DELTA_APPLICATION_WAIT_TIME,
            (NVL(b.CONCURRENCY_WAIT_TIME,0) - NVL(a.CONCURRENCY_WAIT_TIME,0)) DELTA_CONCURRENCY_TIME,
            (NVL(b.CLUSTER_WAIT_TIME,0) - NVL(a.CLUSTER_WAIT_TIME,0)) DELTA_CLUSTER_WAIT_TIME,
            (NVL(b.USER_IO_WAIT_TIME,0) - NVL(a.USER_IO_WAIT_TIME,0)) DELTA_USER_IO_WAIT_TIME,
            (NVL(b.PLSQL_EXEC_TIME,0) - NVL(a.PLSQL_EXEC_TIME,0)) DELTA_PLSQL_EXEC_TIME,
            (NVL(b.JAVA_EXEC_TIME,0) - NVL(a.JAVA_EXEC_TIME,0)) DELTA_JAVA_EXEC_TIME,
            (NVL(b.SORTS,0) - NVL(a.SORTS,0)) DELTA_SORTS,
            (NVL(b.LOADS,0) - NVL(a.LOADS,0)) DELTA_LOADS,
            (NVL(b.INVALIDATIONS,0) - NVL(a.INVALIDATIONS,0)) DELTA_INVALIDATIONS,
            (NVL(b.PHYSICAL_READ_REQUESTS,0) - NVL(a.PHYSICAL_READ_REQUESTS,0)) DELTA_PHYSICAL_READ_REQUESTS,
            (NVL(b.PHYSICAL_READ_BYTES,0) - NVL(a.PHYSICAL_READ_BYTES,0)) DELTA_PHYSICAL_READ_BYTES,
            (NVL(b.PHYSICAL_WRITE_REQUESTS,0) - NVL(a.PHYSICAL_WRITE_REQUESTS,0)) DELTA_PHYSICAL_WRITE_REQUESTS,
            (NVL(b.PHYSICAL_WRITE_BYTES,0) - NVL(a.PHYSICAL_WRITE_BYTES,0)) DELTA_PHYSICAL_WRITE_BYTES,
            (NVL(b.IO_INTERCONNECT_BYTES,0) - NVL(a.IO_INTERCONNECT_BYTES,0)) DELTA_IO_INTERCONNECT_BYTES,
            (NVL(b.IO_CELL_OFFLOAD_ELIGIBLE_BYTES,0) - NVL(a.IO_CELL_OFFLOAD_ELIGIBLE_BYTES,0)) DELTA_CELL_OFFLOAD_ELIG_BYTES,
            (NVL(b.IO_CELL_UNCOMPRESSED_BYTES,0) - NVL(a.IO_CELL_UNCOMPRESSED_BYTES,0)) DELTA_CELL_UNCOMPRESSED_BYTES,
            b.CON_ID,
            b.CON_DBID,
            b.OBSOLETE_COUNT
           FROM b
                LEFT JOIN a ON a.sql_id = b.sql_id AND a.plan_hash_value = b.plan_hash_value);


    UPDATE XDBSNAPSHOT.TBL_SQLSTATS set DELTA_PARSE_CALLS = PARSE_CALLS, DELTA_DISK_READS = DISK_READS, DELTA_DIRECT_WRITES = DIRECT_WRITES, DELTA_BUFFER_GETS = BUFFER_GETS, DELTA_ROWS_PROCESSED = ROWS_PROCESSED, DELTA_FETCH_COUNT = FETCHES, DELTA_EXECUTION_COUNT = EXECUTIONS,
          DELTA_PX_SERVERS_EXECUTIONS = PX_SERVERS_EXECUTIONS, DELTA_END_OF_FETCH_COUNT = END_OF_FETCH_COUNT, DELTA_CPU_TIME = CPU_TIME, DELTA_ELAPSED_TIME = ELAPSED_TIME, DELTA_APPLICATION_WAIT_TIME = APPLICATION_WAIT_TIME, DELTA_CONCURRENCY_TIME = CONCURRENCY_WAIT_TIME,
          DELTA_CLUSTER_WAIT_TIME = CLUSTER_WAIT_TIME, DELTA_USER_IO_WAIT_TIME = USER_IO_WAIT_TIME, DELTA_PLSQL_EXEC_TIME = PLSQL_EXEC_TIME, DELTA_JAVA_EXEC_TIME = JAVA_EXEC_TIME, DELTA_SORTS = SORTS, DELTA_LOADS = LOADS, DELTA_INVALIDATIONS = INVALIDATIONS,
          DELTA_PHYSICAL_READ_REQUESTS = PHYSICAL_READ_REQUESTS, DELTA_PHYSICAL_READ_BYTES = PHYSICAL_READ_BYTES, DELTA_PHYSICAL_WRITE_REQUESTS = PHYSICAL_WRITE_REQUESTS, DELTA_PHYSICAL_WRITE_BYTES = PHYSICAL_WRITE_BYTES, DELTA_IO_INTERCONNECT_BYTES = IO_INTERCONNECT_BYTES, DELTA_CELL_OFFLOAD_ELIG_BYTES = IO_CELL_OFFLOAD_ELIGIBLE_BYTES, DELTA_CELL_UNCOMPRESSED_BYTES = IO_CELL_UNCOMPRESSED_BYTES
    WHERE sample_id = l_seq AND (DELTA_PARSE_CALLS < 0 OR DELTA_DISK_READS < 0 OR DELTA_DIRECT_WRITES < 0 OR DELTA_BUFFER_GETS < 0 OR DELTA_ROWS_PROCESSED < 0 OR DELTA_FETCH_COUNT < 0 OR DELTA_EXECUTION_COUNT < 0 OR
        DELTA_PX_SERVERS_EXECUTIONS < 0 OR DELTA_END_OF_FETCH_COUNT < 0 OR DELTA_CPU_TIME < 0 OR DELTA_ELAPSED_TIME < 0 OR DELTA_APPLICATION_WAIT_TIME < 0 OR DELTA_CONCURRENCY_TIME < 0 OR
        DELTA_CLUSTER_WAIT_TIME < 0 OR DELTA_USER_IO_WAIT_TIME < 0 OR DELTA_PLSQL_EXEC_TIME < 0 OR DELTA_JAVA_EXEC_TIME < 0 OR DELTA_LOADS < 0 OR DELTA_INVALIDATIONS < 0 OR
        DELTA_PHYSICAL_READ_REQUESTS < 0 OR DELTA_PHYSICAL_READ_BYTES < 0 OR DELTA_PHYSICAL_WRITE_REQUESTS < 0 OR DELTA_PHYSICAL_WRITE_BYTES < 0 OR DELTA_IO_INTERCONNECT_BYTES < 0 OR DELTA_CELL_OFFLOAD_ELIG_BYTES < 0 OR DELTA_CELL_UNCOMPRESSED_BYTES < 0);

    INSERT INTO XDBSNAPSHOT.TBL_OSSTAT SELECT l_seq, l_date, s.* FROM v$osstat s;

    INSERT INTO XDBSNAPSHOT.TBL_SQL_TEXT
            SELECT l_seq, l_date, sql_id, sql_fulltext
            FROM v$sqlarea a
            WHERE not exists (SELECT 1 FROM XDBSNAPSHOT.TBL_SQL_TEXT b WHERE a.sql_id=b.sql_id);

    INSERT INTO XDBSNAPSHOT.TBL_SQL_PLAN
            SELECT l_seq, l_date, a.*
            FROM v$sql_plan a
            WHERE not exists (SELECT 1 FROM XDBSNAPSHOT.TBL_SQL_PLAN b WHERE a.sql_id=b.sql_id AND a.plan_hash_value = b.plan_hash_value AND a.child_address = b.child_address);

    COMMIT;

END;

/

BEGIN
  DBMS_SCHEDULER.CREATE_JOB (
   job_name           =>  'XDBSNAPSHOT.ASH10SEC',
   job_type           =>  'STORED_PROCEDURE',
   job_action         =>  'XDBSNAPSHOT.PR_ASH_CAPTURE',
   repeat_interval    =>  'FREQ=SECONDLY;INTERVAL=10', /* every 10 seconds */
   auto_drop          =>   TRUE,
   enabled            =>   TRUE,
   job_class          =>  'DEFAULT_JOB_CLASS',
   comments           =>  'ASH sample 10 sec');
END;
/

BEGIN
  DBMS_SCHEDULER.CREATE_JOB (
   job_name           =>  'XDBSNAPSHOT.AWR15MIN',
   job_type           =>  'STORED_PROCEDURE',
   job_action         =>  'XDBSNAPSHOT.PR_AWR_CAPTURE',
   repeat_interval    =>  'FREQ=MINUTELY;INTERVAL=15', /* every 15 minutes */
   auto_drop          =>   TRUE,
   enabled            =>   TRUE,
   job_class          =>  'DEFAULT_JOB_CLASS',
   comments           =>  'AWR sample 15 min');
END;
/


-- check job status
-- SELECT job_name, enabled FROM DBA_SCHEDULER_JOBS where owner='XDBSNAPSHOT';
-- check dba_scheduler_job_run_details
-- select * from SYS.dba_scheduler_job_run_details where job_name='XDBSNAPSHOT';

-- check created snapshots
-- select * from XDBSNAPSHOT.TBL_SNAPSHOT order by 1 desc;
-- if you have records in this table - jobs are working correctly