/*
    Copyright 2016-2025 Taras Guliak XDBTIME (PRO)
    All rights reserved.
    Version: 2025.02
    
    XDBMONITORING schema contains tables, stored procedures and jobs 
		to collect performance metrics from the performance views.

*/

DEFINE p_db_name = 'db_name'; 			-- example: 'ent-ora-perf'
DEFINE p_app_name = 'app_name'; 		-- example: 'Entitlements'
DEFINE p_data_set = 'data_set'; 		-- example: 'Corp 30k LE 30U 60Arr Retail 100k LE 1U 2Arr'
DEFINE p_description = 'description'; 	-- example: 'Release testing'

-- DROP USER xdbmonitoring CASCADE;

CREATE USER xdbmonitoring IDENTIFIED BY mypassword DEFAULT TABLESPACE USERS QUOTA UNLIMITED ON USERS;

GRANT CONNECT, CREATE SESSION, CREATE TABLE, CREATE SEQUENCE, CREATE PROCEDURE, CREATE JOB, CREATE DATABASE LINK TO xdbmonitoring;

GRANT EXECUTE ON SYS.DEFAULT_JOB_CLASS TO xdbmonitoring;

GRANT SELECT ANY DICTIONARY TO xdbmonitoring;

CREATE TABLE xdbmonitoring.tbl_db_info (
	db_name VARCHAR2(128),
    app_name VARCHAR2(128),
    app_version VARCHAR2(128),
    data_set VARCHAR2(128),
    description VARCHAR2(128),
	PRIMARY KEY (db_name)
);

-- You can specify additional attributes for the database - like what application, version and data set is used.
-- So these atributes can be exported later together with performance metrics and can be useful during comparison.
INSERT INTO xdbmonitoring.tbl_db_info 
(
	db_name,
	app_name,
	app_version,
	data_set,
	description
) 
VALUES 
(
	'&p_db_name',
	'&p_app_name',
	null,
	'&p_data_set',
	'&p_description'
);

CREATE TABLE xdbmonitoring.tbl_ash
(
	SAMPLE_ID INTEGER,
	SAMPLE_TIME DATE,
	SADDR RAW(8),
	SID NUMBER,
	SERIAL# NUMBER,
	AUDSID NUMBER,
	PADDR RAW(8),
	USER# NUMBER,
	USERNAME VARCHAR2(30),
	COMMAND NUMBER,
	OWNERID NUMBER,
	TADDR VARCHAR2(16),
	LOCKWAIT VARCHAR2(16),
	STATUS VARCHAR2(8),
	SERVER VARCHAR2(9),
	SCHEMA# NUMBER,
	SCHEMANAME VARCHAR2(30),
	OSUSER VARCHAR2(30),
	PROCESS VARCHAR2(24),
	MACHINE VARCHAR2(64),
	PORT NUMBER,
	TERMINAL VARCHAR2(30),
	PROGRAM VARCHAR2(48),
	TYPE VARCHAR2(10),
	SQL_ADDRESS RAW(8),
	SQL_HASH_VALUE NUMBER,
	SQL_ID VARCHAR2(13),
	SQL_CHILD_NUMBER NUMBER,
	SQL_EXEC_START DATE,
	SQL_EXEC_ID NUMBER,
	PREV_SQL_ADDR RAW(8),
	PREV_HASH_VALUE NUMBER,
	PREV_SQL_ID VARCHAR2(13),
	PREV_CHILD_NUMBER NUMBER,
	PREV_EXEC_START DATE,
	PREV_EXEC_ID NUMBER,
	PLSQL_ENTRY_OBJECT_ID NUMBER,
	PLSQL_ENTRY_SUBPROGRAM_ID NUMBER,
	PLSQL_OBJECT_ID NUMBER,
	PLSQL_SUBPROGRAM_ID NUMBER,
	MODULE VARCHAR2(64),
	MODULE_HASH NUMBER,
	ACTION VARCHAR2(64),
	ACTION_HASH NUMBER,
	CLIENT_INFO VARCHAR2(64),
	FIXED_TABLE_SEQUENCE NUMBER,
	ROW_WAIT_OBJ# NUMBER,
	ROW_WAIT_FILE# NUMBER,
	ROW_WAIT_BLOCK# NUMBER,
	ROW_WAIT_ROW# NUMBER,
	TOP_LEVEL_CALL# NUMBER,
	LOGON_TIME DATE,
	LAST_CALL_ET NUMBER,
	PDML_ENABLED VARCHAR2(3),
	FAILOVER_TYPE VARCHAR2(13),
	FAILOVER_METHOD VARCHAR2(10),
	FAILED_OVER VARCHAR2(3),
	RESOURCE_CONSUMER_GROUP VARCHAR2(32),
	PDML_STATUS VARCHAR2(8),
	PDDL_STATUS VARCHAR2(8),
	PQ_STATUS VARCHAR2(8),
	CURRENT_QUEUE_DURATION NUMBER,
	CLIENT_IDENTIFIER VARCHAR2(64),
	BLOCKING_SESSION_STATUS VARCHAR2(11),
	BLOCKING_INSTANCE NUMBER,
	BLOCKING_SESSION NUMBER,
	FINAL_BLOCKING_SESSION_STATUS VARCHAR2(11),
	FINAL_BLOCKING_INSTANCE NUMBER,
	FINAL_BLOCKING_SESSION NUMBER,
	SEQ# NUMBER,
	EVENT# NUMBER,
	EVENT VARCHAR2(64),
	P1TEXT VARCHAR2(64),
	P1 NUMBER,
	P1RAW RAW(8),
	P2TEXT VARCHAR2(64),
	P2 NUMBER,
	P2RAW RAW(8),
	P3TEXT VARCHAR2(64),
	P3 NUMBER,
	P3RAW RAW(8),
	WAIT_CLASS_ID NUMBER,
	WAIT_CLASS# NUMBER,
	WAIT_CLASS VARCHAR2(64),
	WAIT_TIME NUMBER,
	SECONDS_IN_WAIT NUMBER,
	STATE VARCHAR2(19),
	WAIT_TIME_MICRO NUMBER,
	TIME_REMAINING_MICRO NUMBER,
	TIME_SINCE_LAST_WAIT_MICRO NUMBER,
	SERVICE_NAME VARCHAR2(64),
	SQL_TRACE VARCHAR2(8),
	SQL_TRACE_WAITS VARCHAR2(5),
	SQL_TRACE_BINDS VARCHAR2(5),
	SQL_TRACE_PLAN_STATS VARCHAR2(10),
	SESSION_EDITION_ID NUMBER,
	CREATOR_ADDR RAW(8),
	CREATOR_SERIAL# NUMBER,
	ECID VARCHAR2(64),
	SQL_TRANSLATION_PROFILE_ID NUMBER,
	PGA_TUNABLE_MEM NUMBER,
	CON_ID NUMBER,
	EXTERNAL_NAME VARCHAR2(1024)
);

CREATE TABLE xdbmonitoring.tbl_sys_time_model
(
	SAMPLE_ID INTEGER,
	SAMPLE_TIME DATE,
	STAT_ID NUMBER,
	STAT_NAME VARCHAR2(64),
	VALUE NUMBER,
	CON_ID NUMBER
);

CREATE TABLE xdbmonitoring.tbl_sysstat
(
	SAMPLE_ID INTEGER,
	SAMPLE_TIME DATE,
	STATISTIC# NUMBER,
	NAME VARCHAR2(64),
	CLASS NUMBER,
	VALUE NUMBER,
	STAT_ID NUMBER,
	CON_ID NUMBER
);

CREATE TABLE xdbmonitoring.tbl_system_event
(
	SAMPLE_ID INTEGER,
	SAMPLE_TIME DATE,
	EVENT VARCHAR2(64),
	TOTAL_WAITS NUMBER,
	TOTAL_TIMEOUTS NUMBER,
	TIME_WAITED NUMBER,
	AVERAGE_WAIT NUMBER,
	TIME_WAITED_MICRO NUMBER,
	TOTAL_WAITS_FG NUMBER,
	TOTAL_TIMEOUTS_FG NUMBER,
	TIME_WAITED_FG NUMBER,
	AVERAGE_WAIT_FG NUMBER,
	TIME_WAITED_MICRO_FG NUMBER,
	EVENT_ID NUMBER,
	WAIT_CLASS_ID NUMBER,
	WAIT_CLASS# NUMBER,
	WAIT_CLASS VARCHAR2(64),
	CON_ID NUMBER
);

CREATE TABLE xdbmonitoring.tbl_sql
(
	SAMPLE_ID INTEGER,
	SAMPLE_TIME DATE,
	SQL_TEXT VARCHAR2(1000),
	SQL_FULLTEXT CLOB,
	SQL_ID VARCHAR2(13),
	SHARABLE_MEM NUMBER,
	PERSISTENT_MEM NUMBER,
	RUNTIME_MEM NUMBER,
	SORTS NUMBER,
	LOADED_VERSIONS NUMBER,
	OPEN_VERSIONS NUMBER,
	USERS_OPENING NUMBER,
	FETCHES NUMBER,
	EXECUTIONS NUMBER,
	PX_SERVERS_EXECUTIONS NUMBER,
	END_OF_FETCH_COUNT NUMBER,
	USERS_EXECUTING NUMBER,
	LOADS NUMBER,
	FIRST_LOAD_TIME VARCHAR2(76),
	INVALIDATIONS NUMBER,
	PARSE_CALLS NUMBER,
	DISK_READS NUMBER,
	DIRECT_WRITES NUMBER,
	BUFFER_GETS NUMBER,
	APPLICATION_WAIT_TIME NUMBER,
	CONCURRENCY_WAIT_TIME NUMBER,
	CLUSTER_WAIT_TIME NUMBER,
	USER_IO_WAIT_TIME NUMBER,
	PLSQL_EXEC_TIME NUMBER,
	JAVA_EXEC_TIME NUMBER,
	ROWS_PROCESSED NUMBER,
	COMMAND_TYPE NUMBER,
	OPTIMIZER_MODE VARCHAR2(10),
	OPTIMIZER_COST NUMBER,
	OPTIMIZER_ENV RAW(2000),
	OPTIMIZER_ENV_HASH_VALUE NUMBER,
	PARSING_USER_ID NUMBER,
	PARSING_SCHEMA_ID NUMBER,
	PARSING_SCHEMA_NAME VARCHAR2(30),
	KEPT_VERSIONS NUMBER,
	ADDRESS RAW(8),
	TYPE_CHK_HEAP RAW(8),
	HASH_VALUE NUMBER,
	OLD_HASH_VALUE NUMBER,
	PLAN_HASH_VALUE NUMBER,
	FULL_PLAN_HASH_VALUE NUMBER,
	CHILD_NUMBER NUMBER,
	SERVICE VARCHAR2(64),
	SERVICE_HASH NUMBER,
	MODULE VARCHAR2(64),
	MODULE_HASH NUMBER,
	ACTION VARCHAR2(64),
	ACTION_HASH NUMBER,
	SERIALIZABLE_ABORTS NUMBER,
	OUTLINE_CATEGORY VARCHAR2(64),
	CPU_TIME NUMBER,
	ELAPSED_TIME NUMBER,
	OUTLINE_SID NUMBER,
	CHILD_ADDRESS RAW(8),
	SQLTYPE NUMBER,
	REMOTE VARCHAR2(1),
	OBJECT_STATUS VARCHAR2(19),
	LITERAL_HASH_VALUE NUMBER,
	LAST_LOAD_TIME VARCHAR2(76),
	IS_OBSOLETE VARCHAR2(1),
	IS_BIND_SENSITIVE VARCHAR2(1),
	IS_BIND_AWARE VARCHAR2(1),
	IS_SHAREABLE VARCHAR2(1),
	CHILD_LATCH NUMBER,
	SQL_PROFILE VARCHAR2(64),
	SQL_PATCH VARCHAR2(30),
	SQL_PLAN_BASELINE VARCHAR2(30),
	PROGRAM_ID NUMBER,
	PROGRAM_LINE# NUMBER,
	EXACT_MATCHING_SIGNATURE NUMBER,
	FORCE_MATCHING_SIGNATURE NUMBER,
	LAST_ACTIVE_TIME DATE,
	BIND_DATA RAW(2000),
	TYPECHECK_MEM NUMBER,
	IO_CELL_OFFLOAD_ELIGIBLE_BYTES NUMBER,
	IO_INTERCONNECT_BYTES NUMBER,
	PHYSICAL_READ_REQUESTS NUMBER,
	PHYSICAL_READ_BYTES NUMBER,
	PHYSICAL_WRITE_REQUESTS NUMBER,
	PHYSICAL_WRITE_BYTES NUMBER,
	OPTIMIZED_PHY_READ_REQUESTS NUMBER,
	LOCKED_TOTAL NUMBER,
	PINNED_TOTAL NUMBER,
	IO_CELL_UNCOMPRESSED_BYTES NUMBER,
	IO_CELL_OFFLOAD_RETURNED_BYTES NUMBER,
	CON_ID NUMBER,
	IS_REOPTIMIZABLE VARCHAR2(1),
	IS_RESOLVED_ADAPTIVE_PLAN VARCHAR2(1),
	IM_SCANS NUMBER,
	IM_SCAN_BYTES_UNCOMPRESSED NUMBER,
	IM_SCAN_BYTES_INMEMORY NUMBER
);

CREATE TABLE xdbmonitoring.tbl_sqlstats
(
	SAMPLE_ID INTEGER,
	SAMPLE_TIME DATE,
	SQL_ID VARCHAR2(13),
	LAST_ACTIVE_TIME DATE,
	LAST_ACTIVE_CHILD_ADDRESS RAW(8),
	PLAN_HASH_VALUE NUMBER,
	PARSE_CALLS NUMBER,
	DISK_READS NUMBER,
	DIRECT_WRITES NUMBER,
	BUFFER_GETS NUMBER,
	ROWS_PROCESSED NUMBER,
	SERIALIZABLE_ABORTS NUMBER,
	FETCHES NUMBER,
	EXECUTIONS NUMBER,
	END_OF_FETCH_COUNT NUMBER,
	LOADS NUMBER,
	VERSION_COUNT NUMBER,
	INVALIDATIONS NUMBER,
	PX_SERVERS_EXECUTIONS NUMBER,
	CPU_TIME NUMBER,
	ELAPSED_TIME NUMBER,
	AVG_HARD_PARSE_TIME NUMBER,
	APPLICATION_WAIT_TIME NUMBER,
	CONCURRENCY_WAIT_TIME NUMBER,
	CLUSTER_WAIT_TIME NUMBER,
	USER_IO_WAIT_TIME NUMBER,
	PLSQL_EXEC_TIME NUMBER,
	JAVA_EXEC_TIME NUMBER,
	SORTS NUMBER,
	SHARABLE_MEM NUMBER,
	TOTAL_SHARABLE_MEM NUMBER,
	TYPECHECK_MEM NUMBER,
	IO_CELL_OFFLOAD_ELIGIBLE_BYTES NUMBER,
	IO_INTERCONNECT_BYTES NUMBER,
	PHYSICAL_READ_REQUESTS NUMBER,
	PHYSICAL_READ_BYTES NUMBER,
	PHYSICAL_WRITE_REQUESTS NUMBER,
	PHYSICAL_WRITE_BYTES NUMBER,
	EXACT_MATCHING_SIGNATURE NUMBER,
	FORCE_MATCHING_SIGNATURE NUMBER,
	IO_CELL_UNCOMPRESSED_BYTES NUMBER,
	IO_CELL_OFFLOAD_RETURNED_BYTES NUMBER,
	DELTA_PARSE_CALLS NUMBER,
	DELTA_DISK_READS NUMBER,
	DELTA_DIRECT_WRITES NUMBER,
	DELTA_BUFFER_GETS NUMBER,
	DELTA_ROWS_PROCESSED NUMBER,
	DELTA_FETCH_COUNT NUMBER,
	DELTA_EXECUTION_COUNT NUMBER,
	DELTA_PX_SERVERS_EXECUTIONS NUMBER,
	DELTA_END_OF_FETCH_COUNT NUMBER,
	DELTA_CPU_TIME NUMBER,
	DELTA_ELAPSED_TIME NUMBER,
	DELTA_APPLICATION_WAIT_TIME NUMBER,
	DELTA_CONCURRENCY_TIME NUMBER,
	DELTA_CLUSTER_WAIT_TIME NUMBER,
	DELTA_USER_IO_WAIT_TIME NUMBER,
	DELTA_PLSQL_EXEC_TIME NUMBER,
	DELTA_JAVA_EXEC_TIME NUMBER,
	DELTA_SORTS NUMBER,
	DELTA_LOADS NUMBER,
	DELTA_INVALIDATIONS NUMBER,
	DELTA_PHYSICAL_READ_REQUESTS NUMBER,
	DELTA_PHYSICAL_READ_BYTES NUMBER,
	DELTA_PHYSICAL_WRITE_REQUESTS NUMBER,
	DELTA_PHYSICAL_WRITE_BYTES NUMBER,
	DELTA_IO_INTERCONNECT_BYTES NUMBER,
	DELTA_CELL_OFFLOAD_ELIG_BYTES NUMBER,
	DELTA_CELL_UNCOMPRESSED_BYTES NUMBER,
	CON_ID NUMBER,
	CON_DBID NUMBER,
	OBSOLETE_COUNT NUMBER
);

CREATE INDEX xdbmonitoring.idx_sqlstats_01 ON xdbmonitoring.tbl_sqlstats (sample_id);

CREATE TABLE xdbmonitoring.tbl_osstat
(
	SAMPLE_ID INTEGER,
	SAMPLE_TIME DATE,
	STAT_NAME VARCHAR2(64),
	VALUE NUMBER,
	OSSTAT_ID NUMBER,
	COMMENTS VARCHAR2(64),
	CUMULATIVE VARCHAR2(3),
	CON_ID NUMBER
);

CREATE TABLE xdbmonitoring.tbl_snapshot
(
	SAMPLE_ID INTEGER,
	SAMPLE_TIME DATE,
	INSTANCE_NUMBER NUMBER,
	INSTANCE_NAME VARCHAR2(16),
	STARTUP_TIME DATE
);

CREATE INDEX xdbmonitoring.idx_snapshot_01 ON xdbmonitoring.tbl_snapshot (sample_id);

CREATE TABLE xdbmonitoring.tbl_sql_text
(
	SAMPLE_ID INTEGER,
	SAMPLE_TIME DATE,
	SQL_ID VARCHAR2(13),
	SQL_FULLTEXT CLOB
);

CREATE INDEX xdbmonitoring.idx_sql_text ON xdbmonitoring.tbl_sql_text (sql_id);

CREATE TABLE xdbmonitoring.tbl_sql_plan
(
	SAMPLE_ID INTEGER,
	SAMPLE_TIME DATE,
	ADDRESS RAW(8),
	HASH_VALUE NUMBER,
	SQL_ID VARCHAR2(13),
	PLAN_HASH_VALUE NUMBER,
	FULL_PLAN_HASH_VALUE NUMBER,
	CHILD_ADDRESS RAW(8),
	CHILD_NUMBER NUMBER,
	TIMESTAMP DATE,
	OPERATION VARCHAR2(120),
	OPTIONS VARCHAR2(120),
	OBJECT_NODE VARCHAR2(160),
	OBJECT# NUMBER,
	OBJECT_OWNER VARCHAR2(128),
	OBJECT_NAME VARCHAR2(128),
	OBJECT_ALIAS VARCHAR2(261),
	OBJECT_TYPE VARCHAR2(80),
	OPTIMIZER VARCHAR2(80),
	ID NUMBER,
	PARENT_ID NUMBER,
	DEPTH NUMBER,
	POSITION NUMBER,
	SEARCH_COLUMNS NUMBER,
	COST NUMBER,
	CARDINALITY NUMBER,
	BYTES NUMBER,
	OTHER_TAG VARCHAR2(140),
	PARTITION_START VARCHAR2(256),
	PARTITION_STOP VARCHAR2(256),
	PARTITION_ID NUMBER,
	OTHER VARCHAR2(4000),
	DISTRIBUTION VARCHAR2(80),
	CPU_COST NUMBER,
	IO_COST NUMBER,
	TEMP_SPACE NUMBER,
	ACCESS_PREDICATES VARCHAR2(4000),
	FILTER_PREDICATES VARCHAR2(4000),
	PROJECTION VARCHAR2(4000),
	TIME NUMBER,
	QBLOCK_NAME VARCHAR2(30),
	REMARKS VARCHAR2(4000),
	OTHER_XML CLOB,
	CON_ID NUMBER
);

CREATE INDEX xdbmonitoring.idx_sql_plan ON xdbmonitoring.tbl_sql_plan (sql_id, plan_hash_value, child_address);

CREATE TABLE xdbmonitoring.tbl_metric 
(
	SAMPLE_ID INTEGER,
	SAMPLE_TIME DATE,
	BEGIN_TIME DATE, 
	END_TIME DATE, 
	INTSIZE_CSEC NUMBER, 
	GROUP_ID NUMBER, 
	ENTITY_ID NUMBER, 
	ENTITY_SEQUENCE NUMBER, 
	METRIC_ID NUMBER, 
	METRIC_NAME VARCHAR2(64), 
	VALUE NUMBER, 
	METRIC_UNIT VARCHAR2(64), 
	CON_ID NUMBER
); 

CREATE SEQUENCE xdbmonitoring.seq_ash
	START WITH 1
	INCREMENT BY 1
	NOCACHE
	NOCYCLE;

CREATE SEQUENCE xdbmonitoring.seq_awr
	START WITH 1
	INCREMENT BY 1
	NOCACHE
	NOCYCLE;

CREATE OR REPLACE PROCEDURE xdbmonitoring.pr_ash_capture AUTHID CURRENT_USER
IS
	l_seq NUMBER;
	l_date DATE := SYSDATE;

BEGIN

	dbms_application_info.set_module('XDBMONITORING','PR_ASH_CAPTURE');

	SELECT XDBMONITORING.SEQ_ASH.nextval INTO l_seq FROM DUAL;

	INSERT INTO XDBMONITORING.TBL_ASH (
		SAMPLE_ID,
		SAMPLE_TIME,
		SADDR,
		SID,
		SERIAL#,
		AUDSID,
		PADDR,
		USER#,
		USERNAME,
		COMMAND,
		OWNERID,
		TADDR,
		LOCKWAIT,
		STATUS,
		SERVER,
		SCHEMA#,
		SCHEMANAME,
		OSUSER,
		PROCESS,
		MACHINE,
		PORT,
		TERMINAL,
		PROGRAM,
		TYPE,
		SQL_ADDRESS,
		SQL_HASH_VALUE,
		SQL_ID,
		SQL_CHILD_NUMBER,
		SQL_EXEC_START,
		SQL_EXEC_ID,
		PREV_SQL_ADDR,
		PREV_HASH_VALUE,
		PREV_SQL_ID,
		PREV_CHILD_NUMBER,
		PREV_EXEC_START,
		PREV_EXEC_ID,
		PLSQL_ENTRY_OBJECT_ID,
		PLSQL_ENTRY_SUBPROGRAM_ID,
		PLSQL_OBJECT_ID,
		PLSQL_SUBPROGRAM_ID,
		MODULE,
		MODULE_HASH,
		ACTION,
		ACTION_HASH,
		CLIENT_INFO,
		FIXED_TABLE_SEQUENCE,
		ROW_WAIT_OBJ#,
		ROW_WAIT_FILE#,
		ROW_WAIT_BLOCK#,
		ROW_WAIT_ROW#,
		TOP_LEVEL_CALL#,
		LOGON_TIME,
		LAST_CALL_ET,
		PDML_ENABLED,
		FAILOVER_TYPE,
		FAILOVER_METHOD,
		FAILED_OVER,
		RESOURCE_CONSUMER_GROUP,
		PDML_STATUS,
		PDDL_STATUS,
		PQ_STATUS,
		CURRENT_QUEUE_DURATION,
		CLIENT_IDENTIFIER,
		BLOCKING_SESSION_STATUS,
		BLOCKING_INSTANCE,
		BLOCKING_SESSION,
		FINAL_BLOCKING_SESSION_STATUS,
		FINAL_BLOCKING_INSTANCE,
		FINAL_BLOCKING_SESSION,
		SEQ#,
		EVENT#,
		EVENT,
		P1TEXT,
		P1,
		P1RAW,
		P2TEXT,
		P2,
		P2RAW,
		P3TEXT,
		P3,
		P3RAW,
		WAIT_CLASS_ID,
		WAIT_CLASS#,
		WAIT_CLASS,
		WAIT_TIME,
		SECONDS_IN_WAIT,
		STATE,
		WAIT_TIME_MICRO,
		TIME_REMAINING_MICRO,
		TIME_SINCE_LAST_WAIT_MICRO,
		SERVICE_NAME,
		SQL_TRACE,
		SQL_TRACE_WAITS,
		SQL_TRACE_BINDS,
		SQL_TRACE_PLAN_STATS,
		SESSION_EDITION_ID,
		CREATOR_ADDR,
		CREATOR_SERIAL#,
		ECID,
		SQL_TRANSLATION_PROFILE_ID,
		PGA_TUNABLE_MEM,
		CON_ID,
		EXTERNAL_NAME
	)
	SELECT 
		l_seq,
		l_date, 
		SADDR,
		SID,
		SERIAL#,
		AUDSID,
		PADDR,
		USER#,
		USERNAME,
		COMMAND,
		OWNERID,
		TADDR,
		LOCKWAIT,
		STATUS,
		SERVER,
		SCHEMA#,
		SCHEMANAME,
		OSUSER,
		PROCESS,
		MACHINE,
		PORT,
		TERMINAL,
		PROGRAM,
		TYPE,
		SQL_ADDRESS,
		SQL_HASH_VALUE,
		SQL_ID,
		SQL_CHILD_NUMBER,
		SQL_EXEC_START,
		SQL_EXEC_ID,
		PREV_SQL_ADDR,
		PREV_HASH_VALUE,
		PREV_SQL_ID,
		PREV_CHILD_NUMBER,
		PREV_EXEC_START,
		PREV_EXEC_ID,
		PLSQL_ENTRY_OBJECT_ID,
		PLSQL_ENTRY_SUBPROGRAM_ID,
		PLSQL_OBJECT_ID,
		PLSQL_SUBPROGRAM_ID,
		MODULE,
		MODULE_HASH,
		ACTION,
		ACTION_HASH,
		CLIENT_INFO,
		FIXED_TABLE_SEQUENCE,
		ROW_WAIT_OBJ#,
		ROW_WAIT_FILE#,
		ROW_WAIT_BLOCK#,
		ROW_WAIT_ROW#,
		TOP_LEVEL_CALL#,
		LOGON_TIME,
		LAST_CALL_ET,
		PDML_ENABLED,
		FAILOVER_TYPE,
		FAILOVER_METHOD,
		FAILED_OVER,
		RESOURCE_CONSUMER_GROUP,
		PDML_STATUS,
		PDDL_STATUS,
		PQ_STATUS,
		CURRENT_QUEUE_DURATION,
		CLIENT_IDENTIFIER,
		BLOCKING_SESSION_STATUS,
		BLOCKING_INSTANCE,
		BLOCKING_SESSION,
		FINAL_BLOCKING_SESSION_STATUS,
		FINAL_BLOCKING_INSTANCE,
		FINAL_BLOCKING_SESSION,
		SEQ#,
		EVENT#,
		EVENT,
		P1TEXT,
		P1,
		P1RAW,
		P2TEXT,
		P2,
		P2RAW,
		P3TEXT,
		P3,
		P3RAW,
		WAIT_CLASS_ID,
		WAIT_CLASS#,
		WAIT_CLASS,
		WAIT_TIME,
		SECONDS_IN_WAIT,
		STATE,
		WAIT_TIME_MICRO,
		TIME_REMAINING_MICRO,
		TIME_SINCE_LAST_WAIT_MICRO,
		SERVICE_NAME,
		SQL_TRACE,
		SQL_TRACE_WAITS,
		SQL_TRACE_BINDS,
		SQL_TRACE_PLAN_STATS,
		SESSION_EDITION_ID,
		CREATOR_ADDR,
		CREATOR_SERIAL#,
		ECID,
		SQL_TRANSLATION_PROFILE_ID,
		PGA_TUNABLE_MEM,
		CON_ID,
		EXTERNAL_NAME
	FROM v$session s 
	WHERE NVL(wait_class,'CPU')!='Idle';

	COMMIT;

END;
/

CREATE OR REPLACE PROCEDURE xdbmonitoring.pr_snap_capture AUTHID CURRENT_USER
IS
	l_seq NUMBER;
	l_date DATE := sysdate;
	l_previouse_sample_id NUMBER;

BEGIN

dbms_application_info.set_module('XDBMONITORING','PR_SNAP_CAPTURE');

SELECT XDBMONITORING.SEQ_AWR.nextval INTO l_seq FROM DUAL;

SELECT NVL(max(sample_id),0) INTO l_previouse_sample_id FROM XDBMONITORING.TBL_SNAPSHOT;

INSERT INTO XDBMONITORING.TBL_SNAPSHOT 
(
	SAMPLE_ID,
	SAMPLE_TIME,
	INSTANCE_NUMBER,
	INSTANCE_NAME,
	STARTUP_TIME
)
SELECT 
	l_seq, 
	l_date, 
	i.instance_number, 
	instance_name, 
	startup_time 
FROM v$instance i;



INSERT INTO XDBMONITORING.TBL_SYS_TIME_MODEL
(
	SAMPLE_ID,
	SAMPLE_TIME,
	STAT_ID,
	STAT_NAME,
	VALUE,
	CON_ID 
) 
SELECT 
	l_seq,
	l_date,
	STAT_ID,
	STAT_NAME,
	VALUE,
	CON_ID 
FROM v$sys_time_model;

INSERT INTO XDBMONITORING.TBL_SYSSTAT 
(
	SAMPLE_ID,
	SAMPLE_TIME,
	STATISTIC#,
	NAME,
	CLASS,
	VALUE,
	STAT_ID,
	CON_ID
)
SELECT 
	l_seq,
	l_date,
	STATISTIC#,
	NAME,
	CLASS,
	VALUE,
	STAT_ID,
	CON_ID
FROM v$sysstat;

INSERT INTO XDBMONITORING.TBL_SYSTEM_EVENT 
(
	SAMPLE_ID,
	SAMPLE_TIME,
	EVENT,
	TOTAL_WAITS,
	TOTAL_TIMEOUTS,
	TIME_WAITED,
	AVERAGE_WAIT,
	TIME_WAITED_MICRO,
	TOTAL_WAITS_FG,
	TOTAL_TIMEOUTS_FG,
	TIME_WAITED_FG,
	AVERAGE_WAIT_FG,
	TIME_WAITED_MICRO_FG,
	EVENT_ID,
	WAIT_CLASS_ID,
	WAIT_CLASS#,
	WAIT_CLASS,
	CON_ID
)
SELECT 
	l_seq,
	l_date,
	EVENT,
	TOTAL_WAITS,
	TOTAL_TIMEOUTS,
	TIME_WAITED,
	AVERAGE_WAIT,
	TIME_WAITED_MICRO,
	TOTAL_WAITS_FG,
	TOTAL_TIMEOUTS_FG,
	TIME_WAITED_FG,
	AVERAGE_WAIT_FG,
	TIME_WAITED_MICRO_FG,
	EVENT_ID,
	WAIT_CLASS_ID,
	WAIT_CLASS#,
	WAIT_CLASS,
	CON_ID
FROM v$system_event;

INSERT INTO XDBMONITORING.TBL_SQLSTATS 
(
	SAMPLE_ID,
	SAMPLE_TIME,
	SQL_ID,
	LAST_ACTIVE_TIME,
	LAST_ACTIVE_CHILD_ADDRESS,
	PLAN_HASH_VALUE,
	PARSE_CALLS,
	DISK_READS,
	DIRECT_WRITES,
	BUFFER_GETS,
	ROWS_PROCESSED,
	SERIALIZABLE_ABORTS,
	FETCHES,
	EXECUTIONS,
	END_OF_FETCH_COUNT,
	LOADS,
	VERSION_COUNT,
	INVALIDATIONS,
	PX_SERVERS_EXECUTIONS,
	CPU_TIME,
	ELAPSED_TIME,
	AVG_HARD_PARSE_TIME,
	APPLICATION_WAIT_TIME,
	CONCURRENCY_WAIT_TIME,
	CLUSTER_WAIT_TIME,
	USER_IO_WAIT_TIME,
	PLSQL_EXEC_TIME,
	JAVA_EXEC_TIME,
	SORTS,
	SHARABLE_MEM,
	TOTAL_SHARABLE_MEM,
	TYPECHECK_MEM,
	IO_CELL_OFFLOAD_ELIGIBLE_BYTES,
	IO_INTERCONNECT_BYTES,
	PHYSICAL_READ_REQUESTS,
	PHYSICAL_READ_BYTES,
	PHYSICAL_WRITE_REQUESTS,
	PHYSICAL_WRITE_BYTES,
	EXACT_MATCHING_SIGNATURE,
	FORCE_MATCHING_SIGNATURE,
	IO_CELL_UNCOMPRESSED_BYTES,
	IO_CELL_OFFLOAD_RETURNED_BYTES,
	DELTA_PARSE_CALLS,
	DELTA_DISK_READS,
	DELTA_DIRECT_WRITES,
	DELTA_BUFFER_GETS,
	DELTA_ROWS_PROCESSED,
	DELTA_FETCH_COUNT,
	DELTA_EXECUTION_COUNT,
	DELTA_PX_SERVERS_EXECUTIONS,
	DELTA_END_OF_FETCH_COUNT,
	DELTA_CPU_TIME,
	DELTA_ELAPSED_TIME,
	DELTA_APPLICATION_WAIT_TIME,
	DELTA_CONCURRENCY_TIME,
	DELTA_CLUSTER_WAIT_TIME,
	DELTA_USER_IO_WAIT_TIME,
	DELTA_PLSQL_EXEC_TIME,
	DELTA_JAVA_EXEC_TIME,
	DELTA_SORTS,
	DELTA_LOADS,
	DELTA_INVALIDATIONS,
	DELTA_PHYSICAL_READ_REQUESTS,
	DELTA_PHYSICAL_READ_BYTES,
	DELTA_PHYSICAL_WRITE_REQUESTS,
	DELTA_PHYSICAL_WRITE_BYTES,
	DELTA_IO_INTERCONNECT_BYTES,
	DELTA_CELL_OFFLOAD_ELIG_BYTES,
	DELTA_CELL_UNCOMPRESSED_BYTES,
	CON_ID,
	CON_DBID,
	OBSOLETE_COUNT
)
SELECT * FROM (
	WITH a AS (SELECT * FROM XDBMONITORING.TBL_SQLSTATS WHERE sample_id = l_previouse_sample_id)
	, b AS (SELECT * FROM v$sqlstats)
	SELECT
		l_seq,
		l_date,
		b.SQL_ID,
		b.LAST_ACTIVE_TIME,
		b.LAST_ACTIVE_CHILD_ADDRESS,
		b.PLAN_HASH_VALUE,
		b.PARSE_CALLS,
		b.DISK_READS,
		b.DIRECT_WRITES,
		b.BUFFER_GETS,
		b.ROWS_PROCESSED,
		b.SERIALIZABLE_ABORTS,
		b.FETCHES,
		b.EXECUTIONS,
		b.END_OF_FETCH_COUNT,
		b.LOADS,
		b.VERSION_COUNT,
		b.INVALIDATIONS,
		b.PX_SERVERS_EXECUTIONS,
		b.CPU_TIME,
		b.ELAPSED_TIME,
		b.AVG_HARD_PARSE_TIME,
		b.APPLICATION_WAIT_TIME,
		b.CONCURRENCY_WAIT_TIME,
		b.CLUSTER_WAIT_TIME,
		b.USER_IO_WAIT_TIME,
		b.PLSQL_EXEC_TIME,
		b.JAVA_EXEC_TIME,
		b.SORTS,
		b.SHARABLE_MEM,
		b.TOTAL_SHARABLE_MEM,
		b.TYPECHECK_MEM,
		b.IO_CELL_OFFLOAD_ELIGIBLE_BYTES,
		b.IO_INTERCONNECT_BYTES,
		b.PHYSICAL_READ_REQUESTS,
		b.PHYSICAL_READ_BYTES,
		b.PHYSICAL_WRITE_REQUESTS,
		b.PHYSICAL_WRITE_BYTES,
		b.EXACT_MATCHING_SIGNATURE,
		b.FORCE_MATCHING_SIGNATURE,
		b.IO_CELL_UNCOMPRESSED_BYTES,
		b.IO_CELL_OFFLOAD_RETURNED_BYTES,
		(NVL(b.PARSE_CALLS,0) - NVL(a.PARSE_CALLS,0)) DELTA_PARSE_CALLS,
		(NVL(b.DISK_READS,0) - NVL(a.DISK_READS,0)) DELTA_DISK_READS,
		(NVL(b.DIRECT_WRITES,0) - NVL(a.DIRECT_WRITES,0)) DELTA_DIRECT_WRITES,
		(NVL(b.BUFFER_GETS,0) - NVL(a.BUFFER_GETS,0)) DELTA_BUFFER_GETS,
		(NVL(b.ROWS_PROCESSED,0) - NVL(a.ROWS_PROCESSED,0)) DELTA_ROWS_PROCESSED,
		(NVL(b.FETCHES,0) - NVL(a.FETCHES,0)) DELTA_FETCH_COUNT,
		(NVL(b.EXECUTIONS,0) - NVL(a.EXECUTIONS,0)) DELTA_EXECUTION_COUNT,
		(NVL(b.PX_SERVERS_EXECUTIONS,0) - NVL(a.PX_SERVERS_EXECUTIONS,0)) DELTA_PX_SERVERS_EXECUTIONS,
		(NVL(b.END_OF_FETCH_COUNT,0) - NVL(a.END_OF_FETCH_COUNT,0)) DELTA_END_OF_FETCH_COUNT,
		(NVL(b.CPU_TIME,0) - NVL(a.CPU_TIME,0)) DELTA_CPU_TIME,
		(NVL(b.ELAPSED_TIME,0) - NVL(a.ELAPSED_TIME,0)) DELTA_ELAPSED_TIME,
		(NVL(b.APPLICATION_WAIT_TIME,0) - NVL(a.APPLICATION_WAIT_TIME,0)) DELTA_APPLICATION_WAIT_TIME,
		(NVL(b.CONCURRENCY_WAIT_TIME,0) - NVL(a.CONCURRENCY_WAIT_TIME,0)) DELTA_CONCURRENCY_TIME,
		(NVL(b.CLUSTER_WAIT_TIME,0) - NVL(a.CLUSTER_WAIT_TIME,0)) DELTA_CLUSTER_WAIT_TIME,
		(NVL(b.USER_IO_WAIT_TIME,0) - NVL(a.USER_IO_WAIT_TIME,0)) DELTA_USER_IO_WAIT_TIME,
		(NVL(b.PLSQL_EXEC_TIME,0) - NVL(a.PLSQL_EXEC_TIME,0)) DELTA_PLSQL_EXEC_TIME,
		(NVL(b.JAVA_EXEC_TIME,0) - NVL(a.JAVA_EXEC_TIME,0)) DELTA_JAVA_EXEC_TIME,
		(NVL(b.SORTS,0) - NVL(a.SORTS,0)) DELTA_SORTS,
		(NVL(b.LOADS,0) - NVL(a.LOADS,0)) DELTA_LOADS,
		(NVL(b.INVALIDATIONS,0) - NVL(a.INVALIDATIONS,0)) DELTA_INVALIDATIONS,
		(NVL(b.PHYSICAL_READ_REQUESTS,0) - NVL(a.PHYSICAL_READ_REQUESTS,0)) DELTA_PHYSICAL_READ_REQUESTS,
		(NVL(b.PHYSICAL_READ_BYTES,0) - NVL(a.PHYSICAL_READ_BYTES,0)) DELTA_PHYSICAL_READ_BYTES,
		(NVL(b.PHYSICAL_WRITE_REQUESTS,0) - NVL(a.PHYSICAL_WRITE_REQUESTS,0)) DELTA_PHYSICAL_WRITE_REQUESTS,
		(NVL(b.PHYSICAL_WRITE_BYTES,0) - NVL(a.PHYSICAL_WRITE_BYTES,0)) DELTA_PHYSICAL_WRITE_BYTES,
		(NVL(b.IO_INTERCONNECT_BYTES,0) - NVL(a.IO_INTERCONNECT_BYTES,0)) DELTA_IO_INTERCONNECT_BYTES,
		(NVL(b.IO_CELL_OFFLOAD_ELIGIBLE_BYTES,0) - NVL(a.IO_CELL_OFFLOAD_ELIGIBLE_BYTES,0)) DELTA_CELL_OFFLOAD_ELIG_BYTES,
		(NVL(b.IO_CELL_UNCOMPRESSED_BYTES,0) - NVL(a.IO_CELL_UNCOMPRESSED_BYTES,0)) DELTA_CELL_UNCOMPRESSED_BYTES,
		b.CON_ID,
		b.CON_DBID,
		b.OBSOLETE_COUNT
	FROM b
		LEFT JOIN a ON a.sql_id = b.sql_id AND a.plan_hash_value = b.plan_hash_value);


UPDATE XDBMONITORING.TBL_SQLSTATS set DELTA_PARSE_CALLS = PARSE_CALLS, DELTA_DISK_READS = DISK_READS, DELTA_DIRECT_WRITES = DIRECT_WRITES, DELTA_BUFFER_GETS = BUFFER_GETS, DELTA_ROWS_PROCESSED = ROWS_PROCESSED, DELTA_FETCH_COUNT = FETCHES, DELTA_EXECUTION_COUNT = EXECUTIONS,
		DELTA_PX_SERVERS_EXECUTIONS = PX_SERVERS_EXECUTIONS, DELTA_END_OF_FETCH_COUNT = END_OF_FETCH_COUNT, DELTA_CPU_TIME = CPU_TIME, DELTA_ELAPSED_TIME = ELAPSED_TIME, DELTA_APPLICATION_WAIT_TIME = APPLICATION_WAIT_TIME, DELTA_CONCURRENCY_TIME = CONCURRENCY_WAIT_TIME,
		DELTA_CLUSTER_WAIT_TIME = CLUSTER_WAIT_TIME, DELTA_USER_IO_WAIT_TIME = USER_IO_WAIT_TIME, DELTA_PLSQL_EXEC_TIME = PLSQL_EXEC_TIME, DELTA_JAVA_EXEC_TIME = JAVA_EXEC_TIME, DELTA_SORTS = SORTS, DELTA_LOADS = LOADS, DELTA_INVALIDATIONS = INVALIDATIONS,
		DELTA_PHYSICAL_READ_REQUESTS = PHYSICAL_READ_REQUESTS, DELTA_PHYSICAL_READ_BYTES = PHYSICAL_READ_BYTES, DELTA_PHYSICAL_WRITE_REQUESTS = PHYSICAL_WRITE_REQUESTS, DELTA_PHYSICAL_WRITE_BYTES = PHYSICAL_WRITE_BYTES, DELTA_IO_INTERCONNECT_BYTES = IO_INTERCONNECT_BYTES, DELTA_CELL_OFFLOAD_ELIG_BYTES = IO_CELL_OFFLOAD_ELIGIBLE_BYTES, DELTA_CELL_UNCOMPRESSED_BYTES = IO_CELL_UNCOMPRESSED_BYTES
WHERE sample_id = l_seq AND (DELTA_PARSE_CALLS < 0 OR DELTA_DISK_READS < 0 OR DELTA_DIRECT_WRITES < 0 OR DELTA_BUFFER_GETS < 0 OR DELTA_ROWS_PROCESSED < 0 OR DELTA_FETCH_COUNT < 0 OR DELTA_EXECUTION_COUNT < 0 OR
	DELTA_PX_SERVERS_EXECUTIONS < 0 OR DELTA_END_OF_FETCH_COUNT < 0 OR DELTA_CPU_TIME < 0 OR DELTA_ELAPSED_TIME < 0 OR DELTA_APPLICATION_WAIT_TIME < 0 OR DELTA_CONCURRENCY_TIME < 0 OR
	DELTA_CLUSTER_WAIT_TIME < 0 OR DELTA_USER_IO_WAIT_TIME < 0 OR DELTA_PLSQL_EXEC_TIME < 0 OR DELTA_JAVA_EXEC_TIME < 0 OR DELTA_LOADS < 0 OR DELTA_INVALIDATIONS < 0 OR
	DELTA_PHYSICAL_READ_REQUESTS < 0 OR DELTA_PHYSICAL_READ_BYTES < 0 OR DELTA_PHYSICAL_WRITE_REQUESTS < 0 OR DELTA_PHYSICAL_WRITE_BYTES < 0 OR DELTA_IO_INTERCONNECT_BYTES < 0 OR DELTA_CELL_OFFLOAD_ELIG_BYTES < 0 OR DELTA_CELL_UNCOMPRESSED_BYTES < 0);

INSERT INTO XDBMONITORING.TBL_OSSTAT
(
	SAMPLE_ID,
	SAMPLE_TIME,
	STAT_NAME,
	VALUE,
	OSSTAT_ID,
	COMMENTS,
	CUMULATIVE,
	CON_ID
)
SELECT 
	l_seq,
	l_date,
	STAT_NAME,
	VALUE,
	OSSTAT_ID,
	COMMENTS,
	CUMULATIVE,
	CON_ID
FROM v$osstat;

INSERT INTO XDBMONITORING.TBL_SQL_TEXT
(
	SAMPLE_ID,
	SAMPLE_TIME,
	SQL_ID,
	SQL_FULLTEXT
)
SELECT 
	l_seq,
	l_date,
	SQL_ID,
	SQL_FULLTEXT
FROM v$sqlarea a
WHERE not exists (SELECT 1 FROM XDBMONITORING.TBL_SQL_TEXT b WHERE a.sql_id=b.sql_id);

INSERT INTO XDBMONITORING.TBL_SQL_PLAN
(
	SAMPLE_ID,
	SAMPLE_TIME,
	ADDRESS,
	HASH_VALUE,
	SQL_ID,
	PLAN_HASH_VALUE,
	FULL_PLAN_HASH_VALUE,
	CHILD_ADDRESS,
	CHILD_NUMBER,
	TIMESTAMP,
	OPERATION,
	OPTIONS,
	OBJECT_NODE,
	OBJECT#,
	OBJECT_OWNER,
	OBJECT_NAME,
	OBJECT_ALIAS,
	OBJECT_TYPE,
	OPTIMIZER,
	ID,
	PARENT_ID,
	DEPTH,
	POSITION,
	SEARCH_COLUMNS,
	COST,
	CARDINALITY,
	BYTES,
	OTHER_TAG,
	PARTITION_START,
	PARTITION_STOP,
	PARTITION_ID,
	OTHER,
	DISTRIBUTION,
	CPU_COST,
	IO_COST,
	TEMP_SPACE,
	ACCESS_PREDICATES,
	FILTER_PREDICATES,
	PROJECTION,
	TIME,
	QBLOCK_NAME,
	REMARKS,
	OTHER_XML,
	CON_ID
)
SELECT 
	l_seq,
	l_date,
	ADDRESS,
	HASH_VALUE,
	SQL_ID,
	PLAN_HASH_VALUE,
	FULL_PLAN_HASH_VALUE,
	CHILD_ADDRESS,
	CHILD_NUMBER,
	TIMESTAMP,
	OPERATION,
	OPTIONS,
	OBJECT_NODE,
	OBJECT#,
	OBJECT_OWNER,
	OBJECT_NAME,
	OBJECT_ALIAS,
	OBJECT_TYPE,
	OPTIMIZER,
	ID,
	PARENT_ID,
	DEPTH,
	POSITION,
	SEARCH_COLUMNS,
	COST,
	CARDINALITY,
	BYTES,
	OTHER_TAG,
	PARTITION_START,
	PARTITION_STOP,
	PARTITION_ID,
	OTHER,
	DISTRIBUTION,
	CPU_COST,
	IO_COST,
	TEMP_SPACE,
	ACCESS_PREDICATES,
	FILTER_PREDICATES,
	PROJECTION,
	TIME,
	QBLOCK_NAME,
	REMARKS,
	OTHER_XML,
	CON_ID
FROM v$sql_plan a
WHERE NOT EXISTS (SELECT 1 FROM XDBMONITORING.TBL_SQL_PLAN b WHERE a.sql_id=b.sql_id AND a.plan_hash_value = b.plan_hash_value AND a.child_address = b.child_address);

INSERT INTO XDBMONITORING.TBL_METRIC
(
	SAMPLE_ID,
	SAMPLE_TIME,
	BEGIN_TIME,
	END_TIME,
	INTSIZE_CSEC,
	GROUP_ID,
	ENTITY_ID,
	ENTITY_SEQUENCE,
	METRIC_ID,
	METRIC_NAME,
	VALUE,
	METRIC_UNIT,
	CON_ID
)
SELECT 	
	l_seq,
	l_date,
	BEGIN_TIME,
	END_TIME,
	INTSIZE_CSEC,
	GROUP_ID,
	ENTITY_ID,
	ENTITY_SEQUENCE,
	METRIC_ID,
	METRIC_NAME,
	VALUE,
	METRIC_UNIT,
	CON_ID 
FROM v$metric WHERE group_id=2; 

COMMIT;

END;
/




BEGIN
DBMS_SCHEDULER.CREATE_JOB (
job_name           =>  'XDBMONITORING.ASH10SEC',
job_type           =>  'STORED_PROCEDURE',
job_action         =>  'XDBMONITORING.PR_ASH_CAPTURE',
repeat_interval    =>  'FREQ=SECONDLY;INTERVAL=10', /* every 10 seconds */
start_date         =>  TO_DATE('01-JAN-22 00:00:00','DD-MON-YY HH24:MI:SS'),
auto_drop          =>   TRUE,
enabled            =>   TRUE,
job_class          =>  'DEFAULT_JOB_CLASS',
comments           =>  'ASH sample 10 sec');
END;
/


-- 5 minute snapshots are created by default. this value can be adjusted
BEGIN
DBMS_SCHEDULER.CREATE_JOB (
job_name           =>  'XDBMONITORING.SNAP5MIN',
job_type           =>  'STORED_PROCEDURE',
job_action         =>  'XDBMONITORING.PR_SNAP_CAPTURE',
repeat_interval    =>  'FREQ=MINUTELY;INTERVAL=5', /* every 5 minutes */
start_date         =>  TO_DATE('01-JAN-22 00:00:00','DD-MON-YY HH24:MI:SS'),
auto_drop          =>   TRUE,
enabled            =>   TRUE,
job_class          =>  'DEFAULT_JOB_CLASS',
comments           =>  'Snapshot sample 5 min');
END;
/

-- check job status
-- SELECT job_name, enabled FROM DBA_SCHEDULER_JOBS where owner='XDBMONITORING';
-- check dba_scheduler_job_run_details
-- select * from SYS.dba_scheduler_job_run_details where owner='XDBMONITORING';

-- check created snapshots
-- select * from XDBMONITORING.TBL_SNAPSHOT order by 1 desc;
-- if you have records in this table - jobs are working correctly    